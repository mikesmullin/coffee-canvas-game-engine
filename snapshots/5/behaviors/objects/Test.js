// Generated by CoffeeScript 1.7.1
(function() {
  var Monster, Player, t,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['components/Behavior', 'lib/Visibility'], function(Behavior, _arg) {
    var Block, EndPoint, Point, Segment, Test, Visibility, Wall;
    Block = _arg.Block, Wall = _arg.Wall, Point = _arg.Point, EndPoint = _arg.EndPoint, Segment = _arg.Segment, Visibility = _arg.Visibility;
    return Test = (function(_super) {
      __extends(Test, _super);

      function Test() {
        var blocks, walls;
        Test.__super__.constructor.apply(this, arguments);
        this.name = 'Test';
        blocks = [new Block(120, 120, 50), new Block(120, 300, 50)];
        walls = [new Wall(new Point(280, 200), new Point(280, 340))];
        this.size = 400;
        this.v = new Visibility;
        this.v.loadMap(this.size, 10, blocks, walls);
        this.player = new Player;
        this.monster = new Monster;
      }

      Test.prototype.Update = function(engine) {
        this.player.x = t(100, 30 / 2, 200, engine.time);
        this.player.y = t(100, 30, 200, engine.time);
        this.v.setVantagePoint(this.player.x, this.player.y);
        this.v.sweep();
        this.player.visibleArea = this.v.computeVisibleAreaPaths(this.v.center, this.v.output).floor;
        this.monster.x = t(10, .5, 25, engine.time);
        this.monster.y = t(100, 9, 200, engine.time);
        this.v.setVantagePoint(this.monster.x, this.monster.y);
        this.v.sweep();
        return this.monster.visibleArea = this.v.computeVisibleAreaPaths(this.v.center, this.v.output).floor;
      };

      Test.prototype.Draw = function(engine) {
        var ctx, grd, traceSvgClippingArea;
        ctx = engine.canvas.ctx;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255, 255, 255, .8)';
        ctx.fillStyle = 'rgba(255, 255, 255, .1)';
        traceSvgClippingArea = function(path) {
          var i;
          ctx.save();
          ctx.beginPath();
          i = 0;
          while (i < path.length) {
            if (path[i] === "M") {
              ctx.moveTo(path[i + 1], path[i + 2]);
              i += 2;
            }
            if (path[i] === "L") {
              ctx.lineTo(path[i + 1], path[i + 2]);
              i += 2;
            }
            i++;
          }
          return ctx.clip();
        };
        traceSvgClippingArea(this.monster.visibleArea);
        grd = ctx.createRadialGradient(this.monster.x, this.monster.y, 10, this.monster.x, this.monster.y, 200);
        grd.addColorStop(0, 'rgba(255,255,255,.1)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(10, 10, this.size - 20, this.size - 20);
        traceSvgClippingArea(this.player.visibleArea);
        grd = ctx.createRadialGradient(this.player.x, this.player.y, 10, this.player.x, this.player.y, 300);
        grd.addColorStop(0, 'rgba(255,255,100,.3)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(10, 10, this.size - 20, this.size - 20);
        ctx.beginPath();
        ctx.fillStyle = 'black';
        ctx.arc(this.player.x, this.player.y, 10, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.fillStyle = 'rgba(0, 100, 100, .8)';
        ctx.fillRect(100, 300, 20, 20);
        ctx.restore();
        ctx.fillStyle = 'red';
        ctx.fillRect(this.monster.x, this.monster.y, 20, 20);
        return ctx.restore();
      };

      return Test;

    })(Behavior);
  });

  t = function(amplitude, period, x0, time) {
    return amplitude * Math.sin(time * 2 * Math.PI / period) + x0;
  };

  Player = (function() {
    function Player(x, y) {
      this.x = x;
      this.y = y;
      this.visibleArea = [];
    }

    return Player;

  })();

  Monster = (function() {
    function Monster(x, y) {
      this.x = x;
      this.y = y;
      this.visibleArea = [];
    }

    return Monster;

  })();

}).call(this);
