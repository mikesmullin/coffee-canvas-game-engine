// Generated by CoffeeScript 1.7.1
(function() {
  define(['lib/Geometry'], function(_arg) {
    var MeshRenderer, Point, Segment;
    Point = _arg.Point, Segment = _arg.Segment;
    return MeshRenderer = (function() {
      function MeshRenderer(_arg1) {
        this.object = _arg1.object;
        this.enabled = true;
        this.vertices = [];
        this.vcount = [];
        this.materials = [{}];
        this.segments = [];
      }

      MeshRenderer.prototype.DisabledDraw = function(engine) {
        var ctx, i, offset, p1, p2, parseSegments, step, vec3, wv, x, x0, y, y0, _i, _j, _k, _len, _len1, _ref, _ref1, _ref2, _ref3, _results;
        ctx = engine.canvas.ctx;
        ctx.lineWidth = this.materials[0].lineWidth || 2;
        ctx.strokeStyle = this.materials[0].strokeStyle || 'rgba(255, 255, 255, .1)';
        ctx.fillStyle = this.materials[0].fillStyle || 'rgba(255, 255, 255, .5)';
        wv = [];
        _ref = this.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vec3 = _ref[_i];
          wv.push(vec3.Clone().Add(this.object.transform.position));
        }
        parseSegments = !this.segments.length;
        offset = 0;
        _ref1 = this.vcount;
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          step = _ref1[_j];
          ctx.beginPath();
          x0 = x = wv[this.indices[offset]].x;
          y0 = y = wv[this.indices[offset]].y;
          ctx.moveTo(x, y);
          if (parseSegments) {
            p1 = new Point(x, y);
          }
          for (i = _k = _ref2 = offset + 2, _ref3 = offset + ((step - 1) * 2); _k <= _ref3; i = _k += 2) {
            x = wv[this.indices[i]].x;
            y = wv[this.indices[i]].y;
            ctx.lineTo(x, y);
            if (parseSegments) {
              p2 = new Point(x, y);
            }
            if (parseSegments) {
              this.segments.push(new Segment(p1, p2));
            }
            if (parseSegments) {
              p1 = new Point(x, y);
            }
          }
          offset = i;
          ctx.closePath();
          if (parseSegments) {
            p2 = new Point(x0, y0);
          }
          if (parseSegments) {
            this.segments.push(new Segment(p1, p2));
          }
          _results.push(ctx.fill());
        }
        return _results;
      };

      return MeshRenderer;

    })();
  });

}).call(this);
