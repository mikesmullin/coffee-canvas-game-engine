// Generated by CoffeeScript 1.7.1
(function() {
  var Block, EndPoint, Point, Segment, Visibility, Wall,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define({
    Block: Block = (function() {
      function Block(x, y, r) {
        this.x = x;
        this.y = y;
        this.r = r;
      }

      return Block;

    })(),
    Wall: Wall = (function() {
      function Wall(p1, p2) {
        this.p1 = p1;
        this.p2 = p2;
      }

      return Wall;

    })(),
    Point: Point = (function() {
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      return Point;

    })(),
    EndPoint: EndPoint = (function(_super) {
      __extends(EndPoint, _super);

      function EndPoint() {
        this.begin = false;
        this.segment = null;
        this.angle = 0.0;
        this.visualize = false;
      }

      return EndPoint;

    })(Point),
    Segment: Segment = (function() {
      function Segment(p1, p2, d) {
        this.p1 = p1;
        this.p2 = p2;
        this.d = d;
      }

      return Segment;

    })(),

    /*
    2D visibility algorithm, for demo
    Usage: new Visibility()
    Whenever map data changes: loadMap()
    Whenever light source changes: setVantagePoint()
    To calculate the area: sweep()
     */
    Visibility: Visibility = (function() {
      function Visibility() {
        this.segments = [];
        this.endpoints = [];
        this.center = new Point(0.0, 0.0);
        this.open = [];
        this.output = [];
        this.demo_intersectionsDetected = [];
      }

      Visibility.prototype.loadEdgeOfMap = function(size, margin) {
        this.addSegment(margin, margin, margin, size - margin);
        this.addSegment(margin, size - margin, size - margin, size - margin);
        this.addSegment(size - margin, size - margin, size - margin, margin);
        return this.addSegment(size - margin, margin, margin, margin);
      };

      Visibility.prototype.loadMap = function(size, margin, blocks, walls) {
        var block, r, wall, x, y, _i, _j, _len, _len1, _results;
        this.segments = [];
        this.endpoints = [];
        this.loadEdgeOfMap(size, margin);
        for (_i = 0, _len = blocks.length; _i < _len; _i++) {
          block = blocks[_i];
          x = block.x;
          y = block.y;
          r = block.r;
          this.addSegment(x - r, y - r, x - r, y + r);
          this.addSegment(x - r, y + r, x + r, y + r);
          this.addSegment(x + r, y + r, x + r, y - r);
          this.addSegment(x + r, y - r, x - r, y - r);
        }
        _results = [];
        for (_j = 0, _len1 = walls.length; _j < _len1; _j++) {
          wall = walls[_j];
          _results.push(this.addSegment(wall.p1.x, wall.p1.y, wall.p2.x, wall.p2.y));
        }
        return _results;
      };

      Visibility.prototype.addSegment = function(x1, y1, x2, y2) {
        var p1, p2, segment;
        segment = null;
        p1 = new EndPoint(0.0, 0.0);
        p1.segment = segment;
        p1.visualize = true;
        p2 = new EndPoint(0.0, 0.0);
        p2.segment = segment;
        p2.visualize = false;
        segment = new Segment();
        p1.x = x1;
        p1.y = y1;
        p2.x = x2;
        p2.y = y2;
        p1.segment = segment;
        p2.segment = segment;
        segment.p1 = p1;
        segment.p2 = p2;
        segment.d = 0.0;
        this.segments.push(segment);
        this.endpoints.push(p1);
        return this.endpoints.push(p2);
      };

      Visibility.prototype.setVantagePoint = function(x, y) {
        var dAngle, dx, dy, segment, _i, _len, _ref, _results;
        this.center.x = x;
        this.center.y = y;
        _ref = this.segments;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          segment = _ref[_i];
          dx = 0.5 * (segment.p1.x + segment.p2.x) - x;
          dy = 0.5 * (segment.p1.y + segment.p2.y) - y;
          segment.d = dx * dx + dy * dy;
          segment.p1.angle = Math.atan2(segment.p1.y - y, segment.p1.x - x);
          segment.p2.angle = Math.atan2(segment.p2.y - y, segment.p2.x - x);
          dAngle = segment.p2.angle - segment.p1.angle;
          if (dAngle <= -Math.PI) {
            dAngle += 2 * Math.PI;
          }
          if (dAngle > Math.PI) {
            dAngle -= 2 * Math.PI;
          }
          segment.p1.begin = dAngle > 0.0;
          _results.push(segment.p2.begin = !segment.p1.begin);
        }
        return _results;
      };

      Visibility.prototype._endpoint_compare = function(a, b) {
        if (a.angle > b.angle) {
          return 1;
        }
        if (a.angle < b.angle) {
          return -1;
        }
        if (!a.begin && b.begin) {
          return 1;
        }
        if (a.begin && !b.begin) {
          return -1;
        }
        return 0;
      };

      Visibility.prototype.leftOf = function(s, p) {
        var cross;
        cross = (s.p2.x - s.p1.x) * (p.y - s.p1.y) - (s.p2.y - s.p1.y) * (p.x - s.p1.x);
        return cross < 0;
      };

      Visibility.prototype.interpolate = function(p, q, f) {
        return new Point(p.x * (1 - f) + q.x * f, p.y * (1 - f) + q.y * f);
      };

      Visibility.prototype._segment_in_front_of = function(a, b, relativeTo) {
        var A1, A2, A3, B1, B2, B3;
        A1 = this.leftOf(a, this.interpolate(b.p1, b.p2, 0.01));
        A2 = this.leftOf(a, this.interpolate(b.p2, b.p1, 0.01));
        A3 = this.leftOf(a, relativeTo);
        B1 = this.leftOf(b, this.interpolate(a.p1, a.p2, 0.01));
        B2 = this.leftOf(b, this.interpolate(a.p2, a.p1, 0.01));
        B3 = this.leftOf(b, relativeTo);
        if (B1 === B2 && B2 !== B3) {
          return true;
        }
        if (A1 === A2 && A2 === A3) {
          return true;
        }
        if (A1 === A2 && A2 !== A3) {
          return false;
        }
        if (B1 === B2 && B2 === B3) {
          return false;
        }
        this.demo_intersectionsDetected.push([a.p1, a.p2, b.p1, b.p2]);
        return false;
      };

      Visibility.prototype.sweep = function(maxAngle) {
        var beginAngle, c, current_new, current_old, i, ii, node, p, pass, _i, _j, _len, _ref;
        if (maxAngle == null) {
          maxAngle = Math.PI;
        }
        this.output = [];
        this.demo_intersectionsDetected = [];
        this.endpoints.sort(this._endpoint_compare, true);
        this.open = [];
        beginAngle = 0.0;
        for (pass = _i = 0; _i < 2; pass = ++_i) {
          _ref = this.endpoints;
          for (c = _j = 0, _len = _ref.length; _j < _len; c = ++_j) {
            p = _ref[c];
            if (pass === 1 && p.angle > maxAngle) {
              break;
            }
            current_old = this.open.length === 0 ? null : this.open[0];
            if (p.begin) {
              i = 0;
              node = this.open;
              while (node[i] !== void 0 && this._segment_in_front_of(p.segment, node[i], this.center)) {
                i++;
              }
              if (node[i] === void 0) {
                this.open.push(p.segment);
              } else {
                this.open.splice(i, 0, p.segment);
                i = i + 1;
              }
            } else {
              while (-1 !== (ii = this.open.indexOf(p.segment))) {
                this.open.splice(ii, 1);
                if (ii <= i) {
                  i = i - 1;
                }
              }
            }
            current_new = this.open.length === 0 ? null : this.open[0];
            if (current_old !== current_new) {
              if (pass === 1) {
                this.addTriangle(beginAngle, p.angle, current_old);
              }
              beginAngle = p.angle;
            }
          }
        }
      };

      Visibility.prototype.lineIntersection = function(p1, p2, p3, p4) {
        var s;
        s = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / ((p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y));
        return new Point(p1.x + s * (p2.x - p1.x), p1.y + s * (p2.y - p1.y));
      };

      Visibility.prototype.addTriangle = function(angle1, angle2, segment) {
        var p1, p2, p3, p4, pBegin, pEnd;
        p1 = this.center;
        p2 = new Point(this.center.x + Math.cos(angle1), this.center.y + Math.sin(angle1));
        p3 = new Point(0.0, 0.0);
        p4 = new Point(0.0, 0.0);
        if (segment !== null) {
          p3.x = segment.p1.x;
          p3.y = segment.p1.y;
          p4.x = segment.p2.x;
          p4.y = segment.p2.y;
        } else {
          p3.x = this.center.x + Math.cos(angle1) * 500;
          p3.y = this.center.y + Math.sin(angle1) * 500;
          p4.x = this.center.x + Math.cos(angle2) * 500;
          p4.y = this.center.y + Math.sin(angle2) * 500;
        }
        pBegin = this.lineIntersection(p3, p4, p1, p2);
        p2.x = this.center.x + Math.cos(angle2);
        p2.y = this.center.y + Math.sin(angle2);
        pEnd = this.lineIntersection(p3, p4, p1, p2);
        this.output.push(pBegin);
        return this.output.push(pEnd);
      };

      Visibility.prototype.computeVisibleAreaPaths = function(center, output) {
        var i, p1, p2, path1, path2, path3;
        path1 = [];
        path2 = [];
        path3 = [];
        i = 0;
        while (i < output.length) {
          p1 = output[i];
          p2 = output[i + 1];
          if (isNaN(p1.x) || isNaN(p1.y) || isNaN(p2.x) || isNaN(p2.y)) {
            continue;
          }
          path1.push("L", p1.x, p1.y, "L", p2.x, p2.y);
          path2.push("M", center.x, center.y, "L", p1.x, p1.y, "M", center.x, center.y, "L", p2.x, p2.y);
          path3.push("M", p1.x, p1.y, "L", p2.x, p2.y);
          i += 2;
        }
        return {
          floor: path1,
          triangles: path2,
          walls: path3
        };
      };

      Visibility.prototype.getEndpointAngles = function() {
        var angles, endpoint, _i, _len, _ref;
        angles = [];
        _ref = this.endpoints;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          endpoint = _ref[_i];
          if (angles.length === 0 || endpoint.angle !== angles[angles.length - 1]) {
            angles.push(endpoint.angle);
          }
        }
        return angles;
      };

      return Visibility;

    })()
  });

}).call(this);
