// Generated by CoffeeScript 1.7.1
(function() {
  define(['lib/Geometry'], function(_arg) {
    var Point, Segment, SegmentCollider;
    Point = _arg.Point, Segment = _arg.Segment;
    return SegmentCollider = (function() {
      function SegmentCollider(_arg1) {
        this.object = _arg1.object, this.is_trigger = _arg1.is_trigger;
        this.enabled = true;
        this.is_trigger || (this.is_trigger = false);
      }

      SegmentCollider.CollisionFlags = {
        None: 0,
        Sides: 2,
        Above: 4,
        Below: 8
      };

      SegmentCollider.prototype.Move = function(engine, dest) {
        var cls, component, event, obj, projected_segments, script, seg, segA, segB, _base, _base1, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
        if (!((_ref = this.object.renderer) != null ? _ref.segments : void 0)) {
          throw 'cant check an object without segments';
        }
        projected_segments = [];
        _ref1 = this.object.renderer.segments;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          seg = _ref1[_i];
          projected_segments.push(new Segment(new Point(seg.p1.x + dest.x, seg.p1.y + dest.y), new Point(seg.p2.x + dest.x, seg.p2.y + dest.y)));
        }
        _ref2 = engine.objects;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          obj = _ref2[_j];
          if (obj !== this.object && (((_ref3 = obj.renderer) != null ? _ref3.segments : void 0) != null)) {
            for (_k = 0, _len2 = projected_segments.length; _k < _len2; _k++) {
              segA = projected_segments[_k];
              _ref4 = obj.renderer.segments;
              for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
                segB = _ref4[_l];
                if (this.SegmentsCollide(segA.p1.x, segA.p1.y, segA.p2.x, segA.p2.y, segB.p1.x, segB.p1.y, segB.p2.x, segB.p2.y)) {
                  if (this.is_trigger) {
                    event = 'OnControllerColliderHit';
                    if (typeof (_base = this.object)[event] === "function") {
                      _base[event](engine, obj);
                    }
                    _ref5 = ['renderer', 'collider'];
                    for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
                      component = _ref5[_m];
                      if ((_ref6 = this.object[component]) != null ? _ref6.enabled : void 0) {
                        if (typeof (_base1 = this.object[component])[event] === "function") {
                          _base1[event](engine, obj);
                        }
                      }
                    }
                    _ref7 = this.object.scripts;
                    for (cls in _ref7) {
                      script = _ref7[cls];
                      if (script.enabled) {
                        if (typeof script[event] === "function") {
                          script[event](engine, obj);
                        }
                      }
                    }
                  }
                  return SegmentCollider.CollisionFlags.Sides;
                }
              }
            }
          }
        }
        this.object.transform.position.x += dest.x;
        this.object.transform.position.y += dest.y;
        return SegmentCollider.CollisionFlags.None;
      };

      SegmentCollider.prototype.SegmentsCollide = function(a, b, c, d, p, q, r, s) {
        var det, gamma, lambda;
        det = (c - a) * (s - q) - (r - p) * (d - b);
        if (det === 0) {
          return false;
        }
        lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
        gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
        return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
      };

      return SegmentCollider;

    })();
  });

}).call(this);
