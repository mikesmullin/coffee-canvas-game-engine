// Generated by CoffeeScript 1.7.1
(function() {
  define(['async2'], function(async) {
    var GlTF;
    return GlTF = (function() {
      function GlTF() {}

      GlTF.GetFile = function(type, url, cb) {
        var xhr;
        xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (this.readyState === 4 && this.status === 200) {
            return cb(this.response);
          }
        };
        xhr.open('GET', url);
        xhr.responseType = type;
        return xhr.send();
      };

      GlTF.GetAttrVal = function(mapRoot, data, accessor_id, cb) {
        var a, accessor, b, buffer, bufferView;
        accessor = data.accessors[accessor_id];
        bufferView = data.bufferViews[accessor.bufferView];
        buffer = data.buffers[bufferView.buffer];
        a = (function(_this) {
          return function(next) {
            if (buffer.data) {
              return next();
            }
            return _this.GetFile('blob', "" + mapRoot + "/" + buffer.uri, function(bin) {
              var reader;
              if (buffer.type === 'arraybuffer') {
                reader = new FileReader;
                reader.addEventListener('loadend', function() {
                  buffer.data = reader.result;
                  return next();
                });
                return reader.readAsArrayBuffer(bin);
              }
            });
          };
        })(this);
        b = function() {
          var attrSlice, viewSlice;
          viewSlice = buffer.data.slice(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);
          attrSlice = viewSlice.slice(accessor.byteOffset, accessor.byteOffset + ((accessor.byteStride || 1) * accessor.count));
          if (accessor.type === 'VEC3') {
            return cb(new Float32Array(attrSlice));
          } else if (accessor.type === 'SCALAR' && accessor.componentType === 5123) {
            return cb(new Uint16Array(attrSlice));
          }
        };
        return a(b);
      };

      GlTF.LoadMap = function(mapRoot, map, done_cb, cb) {
        return this.GetFile('application/json', "" + mapRoot + "/" + map, (function(_this) {
          return function(response) {
            var child, color, data, flow, id, matrixHierarchy, node, rgba, _fn, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
            data = JSON.parse(response);
            flow = new async;
            matrixHierarchy = [];
            _ref = data.scenes[data.scene].nodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              node = _ref[_i];
              matrixHierarchy.push(data.nodes[node].matrix);
              _ref1 = data.nodes[node].children;
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                child = _ref1[_j];
                matrixHierarchy.push(data.nodes[child].matrix);
                _ref2 = data.nodes[child].meshes;
                _fn = function(id, h, color) {
                  return flow.serial(function(next) {
                    return _this.GetAttrVal(mapRoot, data, data.meshes[id].primitives[0].indices, function(indices) {
                      return _this.GetAttrVal(mapRoot, data, data.meshes[id].primitives[0].attributes.POSITION, function(vertices) {
                        cb(data.meshes[id].name, h, color, vertices, indices, data.meshes[id].primitives[0].primitive);
                        return next();
                      });
                    });
                  });
                };
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  id = _ref2[_k];
                  color = '';
                  rgba = (_ref3 = data.materials[data.meshes[id].primitives[0].material].instanceTechnique.values) != null ? _ref3.diffuse : void 0;
                  color = "rgba(" + (Math.ceil(60 + (255 * rgba[0]))) + ", " + (Math.ceil(30 + (255 * rgba[1]))) + ", " + (Math.ceil(0 + (255 * rgba[2]))) + ", " + (Math.round(rgba[3], 1)) + ")";
                  _fn(id, matrixHierarchy.slice(0), color);
                }
                matrixHierarchy.pop();
              }
            }
            return flow.go(function(err) {
              return done_cb();
            });
          };
        })(this));
      };

      return GlTF;

    })();
  });

}).call(this);
