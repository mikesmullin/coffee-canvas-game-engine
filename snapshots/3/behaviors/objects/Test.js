// Generated by CoffeeScript 1.7.1
(function() {
  var t,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(['../components/Behavior', '../lib/Visibility', '../lib/Trig'], function(Behavior, _arg, Trig) {
    var Block, EndPoint, Point, Segment, Test, Visibility, Wall;
    Block = _arg.Block, Wall = _arg.Wall, Point = _arg.Point, EndPoint = _arg.EndPoint, Segment = _arg.Segment, Visibility = _arg.Visibility;
    return Test = (function(_super) {
      __extends(Test, _super);

      function Test() {
        var blocks, walls;
        Test.__super__.constructor.apply(this, arguments);
        this.name = 'Test';
        this.v = new Visibility;
        this.v["new"]();
        blocks = [new Block(120, 120, 50), new Block(120, 300, 50)];
        walls = [new Wall(new Point(280, 200), new Point(280, 340))];
        this.size = 400;
        this.v.loadMap(this.size, 10, blocks, walls);
      }

      Test.prototype.Start = function(engine, cb) {
        return cb();
      };

      Test.prototype.Update = function(engine) {
        var interval, x, y;
        x = 200;
        y = 200;
        interval = 30;
        this.x = t(100, interval / 2, x, engine.time);
        this.y = t(100, interval, y, engine.time);
        this.v.setLightLocation(this.x, this.y);
        return this.v.sweep();
      };

      Test.prototype.Draw = function(engine) {
        var ctx, grd, interpretSvg, paths, seg, _i, _len, _ref;
        ctx = engine.canvas.ctx;
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(255, 255, 255, .8)';
        ctx.fillStyle = 'rgba(255, 255, 255, .5)';
        _ref = this.v.segments;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          seg = _ref[_i];
          ctx.beginPath();
          ctx.moveTo(seg.p1.x, seg.p1.y);
          ctx.lineTo(seg.p2.x, seg.p2.y);
          ctx.stroke();
        }
        interpretSvg = function(ctx, path) {
          var i;
          i = 0;
          while (i < path.length) {
            if (path[i] === "M") {
              ctx.moveTo(path[i + 1], path[i + 2]);
              i += 2;
            }
            if (path[i] === "L") {
              ctx.lineTo(path[i + 1], path[i + 2]);
              i += 2;
            }
            i++;
          }
        };
        paths = this.v.computeVisibleAreaPaths(this.v.center, this.v.output);
        ctx.save();
        ctx.beginPath();
        interpretSvg(ctx, paths.floor);
        ctx.clip();
        grd = ctx.createRadialGradient(this.v.center.x, this.v.center.y, 10, this.v.center.x, this.v.center.y, 300);
        grd.addColorStop(0, 'rgba(255,255,80,1)');
        grd.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grd;
        ctx.fillRect(10, 10, this.size, this.size);
        ctx.strokeStyle = 'blue';
        ctx.fillStyle = 'black';
        ctx.strokeWidth = 2;
        ctx.beginPath();
        ctx.arc(this.v.center.x, this.v.center.y, 10, 0, Math.PI * 2, true);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = 'red';
        ctx.fillRect(t(10, .5, 200, engine.time), t(10, 9, 100, engine.time), 20, 20);
        ctx.fillStyle = 'rgba(0, 100, 100, .8)';
        ctx.fillRect(100, 300, 20, 20);
        ctx.restore();
        engine.Info("x: " + (this.x.toFixed(3)) + ", y:, " + (this.y.toFixed(3)) + "           ", 33, 'gray', 12);
        return engine.Info("WARNING: freezes sometimes. refresh to fix.    ", 33, 'red', 13);
      };

      return Test;

    })(Behavior);
  });

  t = function(amplitude, period, x0, time) {
    return amplitude * Math.sin(time * 2 * Math.PI / period) + x0;
  };

}).call(this);
